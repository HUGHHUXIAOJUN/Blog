---
layout:     post
title:      从输入URL到页面呈现过程
date:       2018-6-03 
author:     Chaser
header-img: 
catalog: true
tags:
    - http
    - html&css
---

> 这可谓是一个非常常见的前端考验题目，网上的答案解释也是琳琅满目，但仍然值得每一个前端的初学者去思考。

# 总体过程    
- 地址栏输入url
- 浏览器通过DNS域名解析得到该url的IP地址
- 客户端与服务器端建立TCP连接（TCP三次握手）
- 浏览器向服务器发送Http请求
- 服务器响应Http请求，将请求的资源发送给浏览器
- 浏览器获取资源，解析HTML形成DOM Tree，将CSS代码解析为CSS RULE Tree
- DOM Tree 和 CSS RULE Tree 结合生成Render Tree
- 渲染页面
- 客户端与服务器关闭TCP连接（TCP四次挥手）  

## 1.地址栏输入url  
url称为统一资源定位符，例如`http://www.baidu.com/`就是一个url。 

## 2.浏览器通过DNS域名解析得到该url的IP地址
浏览器要解释这个域名，首先会查看**本地DNS缓存**是否存在这个域名对应的IP地址。  
如果没有就会从查看电脑上的**host文件**是否存在域名对应的IP规则。  
若再没有，则会发送DNS请求到**本地DNS服务器或其他DNS服务器**获取对应的IP地址（此过程会采用递归或者迭代的方式进行）。
![](http://mmbiz.qpic.cn/mmbiz_jpg/NVvB3l3e9aGS2KZjibulcKSx4K7gmiaDR3oxyoc5ry7GRAjL3XEmxkuAvcOuTo2eV6RtM23EubzKcxat8LOnjibjA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1)

## 3.客户端与服务器端建立TCP连接（TCP三次握手）
> 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。  

![](https://segmentfault.com/img/bVDcBf?w=719&h=800)  

> ACK: ACK=1表示该报文段中有确认号需要处理。
SYN: SYN=1 ACK=0表明是建立连接请求报文段，SYN=1 ACK=1表明同意建立连接报文。
FIN: FIN=1表示对端的数据已经发送完毕，要求释放连接。

### 第一次握手：建立连接
客户端发送连接请求报文段，将SYN值设为1，`Sequence Number`为x。客户端进入`SYN_SEND`状态，等待服务器的确认。

### 第二次握手: 服务器收到SYN报文段
服务器收到客户端SYN报文段，需要对这个SYN报文段进行确认，设置`Acknowledgment Number`为x+1(`Sequence Number+1`)。同时，自己自己还要发送SYN请求信息，将SYN值设为1，`Sequence Number`设为y。服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，服务器进入`SYN_RECV`状态。

### 第三次握手：客户端收到SYN+ACK报文段
客户端收到服务器的SYN+ACK报文段后将`Acknowledgment Number`设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入`ESTABLISHED`状态，完成TCP三次握手。

> 至于为什么要三次握手，而不是两次？

因为可能存在这样的情况：  

现假定A要与B建立TCP连接，A向B发送一个连接请求，但因为网络延迟滞留了。以至于发送第二次请求，第二次连接成功，数据传输完成并且释放连接了，然后此时第一次的接连请求才到达B。本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。如果不采用三次握手，那么只要B发出确认，新的连接就建立了，但这并不符合本意。

所以采用多一次握手的方法（即三次握手）可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。

## 4.浏览器向服务器发送Http请求
建立TCP连接后就会发送Http请求，一个Http请求包括请求头和请求正文。请求头包含了请求的方法，例如：Get和Post方法。

## 5.服务器响应Http请求，将请求的资源发送给浏览器
服务器收到请求后进行处理，返回一个Http响应。一个Http响应与Http请求类似，也包含一个头部和一个正文部分。而这里的正文部分包含了我们需要的资源比如html,image等等。

## 6.浏览器获取资源，解析HTML形成DOM Tree，将CSS代码解析为CSS RULE Tree 

浏览器在解析html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。但是若当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM。

解析过程中，浏览器首先会解析HTML文件构建DOM tree，然后解析CSS文件构建CSS RULE tree。

## 7.DOM Tree 和 CSS RULE Tree 结合生成Render Tree

![](https://segmentfault.com/img/bVsaPc)

display:none 的节点会加入DOM Tree，但不会被加入Render Tree，而visibility: hidden 则两者都会。

- display : 隐藏对应的元素但不挤占该元素原来的空间。
- visibility: 隐藏对应的元素并且挤占该元素原来的空间

所以，如果某个节点最开始是不显示的，设为display:none是更优的。

## 8.渲染页面

### 布局
有了Render Tree，浏览器知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。接着就开始布局，计算出每个节点在屏幕中的位置。  
### 渲染
浏览器已经知道了哪些节点要显示、每个节点的CSS属性是什么、每个节点在屏幕中的位置是哪里。就进入了最后一步，按照算出来的规则，通过显卡，把内容画到屏幕上。

而 javascript 又可以根据 DOM API 操作DOM。比如JS修改了DOM或者CSS属性，也会重新触发布局（重排或回流）和渲染（重绘）的执行过程。这两个概念将在之后文章再谈。

## 9.客户端与服务器关闭TCP连接（TCP四次挥手）
>这里可以结合上面进行TCP三次握手的图进行理解。

### 第一次挥手：客户端想分手
假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包`(FIN=1，seq=x)`，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
发送完毕后，客户端进入`FIN_WAIT_1`状态。

### 第二次挥手：服务端也想分手
服务器端确认客户端的 FIN包，发送一个确认包(`ACK=1`，`ACKnum=x+1`)，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入`FIN_WAIT_2` 状态，等待服务器端关闭连接。

### 第三次挥手：服务端准备好分手
服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN置为1(`FIN=1`，`seq=y`)。
发送完毕后，服务器端进入`LAST_ACK` 状态，等待来自客户端的最后一个ACK。

### 第四次挥手：分手
客户端接收到来自服务器端的关闭请求，发送一个确认包(`ACK=1`，`ACKnum=y+1`)，并进入`TIME_WAIT`状态，等待可能出现的要求重传的 ACK包。
服务器端接收到这个确认包之后，关闭连接，进入`CLOSED`状态。
客户端等待2MSL（2MSL，`2 Maximum Segment Lifetime`）之后，没有收到回复，确保服务器端确实是关闭了，客户端也关闭连接，进入`CLOSED`状态。


